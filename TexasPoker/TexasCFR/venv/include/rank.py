class HandRank:	"""	Rank:	Royal-flush? (9, 0, 0, 0, 0)	Straight-flush? (8, highest card, 0, 0, 0, 0)	4-of-a-kind? (7, card in 4s, kicker, 0, 0, 0)	Full house? (6, card in 3s, card in 2s, 0, 0, 0)	Flush? (5, highest card, 2nd, 3rd, 4th, 5th)	Straight? (4, highest card, 0, 0, 0, 0)	3-of-a-kind? (3, card in 3s, kicker, 2nd, 0, 0)	2 pairs? (2, high pair, low pair, kicker, 0, 0)	Pair? (1, pair, kicker, 2nd, 3rd, 0)	Nothing? (0, 1st, 2nd, 3rd, 4th, 5th)	All cards are stored by rank, which then uses tuple comparison to determine	the greatest value	"""	def __init__(self, player, communitycards):		player.hands.append(communitycards[0])		player.hands.append(communitycards[1])		player.hands.append(communitycards[2])		player.hands.append(communitycards[3])		player.hands.append(communitycards[4])		self.cards = player.hands		# print(self.cards)		pass	# Takes the hand and evaluates it as a tuple of (rank, high1, high2, high3, high4, high5)	def evaluate(self):		if self.royal_flush():			return [9, 0, 0, 0, 0, 0]		elif self.straight_flush():			is_straight_flush = self.straight_flush()			return [8, is_straight_flush[0], 0, 0, 0, 0]		elif self.four_of_a_kind():			is_fours = self.four_of_a_kind()			return [7, is_fours[0], is_fours[1], 0, 0, 0]		elif self.full_house():			is_full_house = self.full_house()			return [6, is_full_house[0], is_full_house[1], 0, 0, 0]		elif self.flush():			is_flush = self.flush()			return [5, is_flush[0], is_flush[1], is_flush[2], is_flush[3], is_flush[4]]		elif self.straight():			is_straight = self.straight()			return [4, is_straight[0], 0, 0, 0, 0]		elif self.three_of_a_kind():			is_threes = self.three_of_a_kind()			return [3, is_threes[0], is_threes[1], is_threes[2], 0, 0]		elif self.two_pairs():			is_two_pairs = self.two_pairs()			return [2, is_two_pairs[0], is_two_pairs[1], is_two_pairs[2], 0, 0]		elif self.pair():			is_pair = self.pair()			return [1, is_pair[0], is_pair[1], is_pair[2], is_pair[3], 0]		else:			is_high_card = self.high_card()			return [0, is_high_card[0], is_high_card[1], is_high_card[2], is_high_card[3], is_high_card[4]]		pass	# Take all of the cards and splits them into four groups, based on suit	# Optionally can be given a different set of cards to group (say a subset)	def group_by_suit(self):		groups = {"heart": [], 'club': [], 'diamond': [], 'spade': []}		for each in self.cards:			groups[each.suit].append(each)			pass		return groups	# Take all of the cards and splits them into fourteen groups, based on rank	# Optionally can be given a different set of cards to group (say a subset)	def group_by_rank(self, the_cards=None):		if the_cards is None:			the_cards = self.cards			pass		pass		groups = {1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [], 11: [], 12: [], 13: [], 14: []}		for each in the_cards:			rank = each.get_rank()			groups[rank].append(each)			# Ace is both a high and a low card			if rank == 14:				groups[1].append(each)				pass			pass		return groups	# Generalize search for 4-of-a-kind, 3-of-a-kind, 2-of-a-kinds, etc.	def n_of_a_kind(self, n):		ranks = self.group_by_rank()		for loop_i in range(14, 1, -1):			if len(ranks[loop_i]) >= n:				# Delete the n of a kind and start looking for the kicker				ranks[loop_i] = ranks[loop_i][n:]				return_value = [loop_i]				for num_kickers in range(5 - n):					for loop_j in range(14, 1, -1):						if len(ranks[loop_j]) >= 1:							return_value.append(loop_j)							ranks[loop_j] = ranks[loop_j][1:]							break							pass						pass					pass				return return_value		return None	# straight flush judge and comprise	def royal_flush(self):		suits = self.group_by_suit()		for suit in suits.keys():			# We have to have at least 5 cards to have a straight			if len(suits[suit]) >= 5:				ranks = self.group_by_rank(suits[suit])				if len(ranks[14]) > 0 and len(ranks[13]) > 0 and \					len(ranks[12]) > 0 and len(ranks[11]) > 0 and \					len(ranks[10]) > 0: 					return True				else:					return False				pass			pass		pass	# straight flush judge and comprise	def straight_flush(self):		suits = self.group_by_suit()		has_straight_flush = False		best_straight = 0		for suit in suits.keys():			highest_straight = 0			# We have to have at least 5 cards to have a straight			if len(suits[suit]) >= 5:				ranks = self.group_by_rank(suits[suit])				num_in_a_row = 0				for i in range(14, 0, -1):					if len(ranks[i]) > 0:						num_in_a_row += 1						pass					else:						num_in_a_row = 0						pass					pass					# No more need to keep going, we have the highest straight flush for this suit					if num_in_a_row >= 5:						highest_straight = i + 4						has_straight_flush = True						break						pass					pass				pass			pass			if highest_straight > best_straight:				best_straight = highest_straight				pass			pass		pass		if has_straight_flush:			return [best_straight]		else:			return None	# four of a kind judge and comprise	def four_of_a_kind(self):		return self.n_of_a_kind(4)	# full house judge and comprise	def full_house(self):		ranks = self.group_by_rank()		for r in range(14, 1, -1):			if len(ranks[r]) >= 3:				# Delete the three of a kind and look for a pair				ranks[r] = ranks[r][3:]				for p in range(14, 1, -1):					if len(ranks[p]) >= 2:						return [r, p]					pass				pass			pass		return None	# flush judge and comprise	def flush(self):		has_flush = False		best_order = []		suits = self.group_by_suit()		# If the suit has a flush, then figure out its best order		for suit in suits.keys():			if len(suits[suit]) >= 5:				has_flush = True				ranks = self.group_by_rank(suits[suit])				for number in range(14, 0, -1):					for loop_i in range(len(ranks[number])):						best_order.append(number)						pass					pass				pass			pass		pass		if has_flush:			return best_order		else:			return None		pass	# straight house judge and comprise	def straight(self):		ranks = self.group_by_rank()		num_in_a_row = 0		for r in range(14, 0, -1):			if len(ranks[r]) > 0:				num_in_a_row += 1			else:				num_in_a_row = 0				pass			pass			if num_in_a_row >= 5:				return [r + 4]			pass		return None	# three of a kind judge and comprise	def three_of_a_kind(self):		return self.n_of_a_kind(3)	# two pairs judge and comprise	def two_pairs(self):		ranks = self.group_by_rank()		for first in range(14, 1, -1):			if len(ranks[first]) >= 2:				# Delete the pair and look for another				ranks[first] = ranks[first][2:]				for second in range(14, 1, -1):					if len(ranks[second]) >= 2:						# Delete the second pair and look for a kicker						ranks[second] = ranks[second][2:]						for third in range(14, 1, -1):							if len(ranks[third]) >= 1:								return [first, second, third]							pass						pass					pass				pass			pass		return None	# pair judge and comprise	def pair(self):		return self.n_of_a_kind(2)	# high card judge and comprise	def high_card(self):		ranks = self.group_by_rank()		best = []		for number in range(14, 0, -1):			for loop_i in range(len(ranks[number])):				best.append(number)				pass			pass		pass		return best	# Evaluate the hand and returns a string with the name of the hand for display purposes.	def hand_name(self):		ranking = self.evaluate()		if ranking[0] == 8:			if ranking[1] == 14:				text = "royal flush!"			else:				text = self.get_rank_string(ranking[1]) + "-high straight flush."				pass			pass		elif ranking[0] == 7:			text = "four " + self.get_rank_string_pluralize(ranking[1]) + "."			pass		elif ranking[0] == 6:			text = self.get_rank_string_pluralize(ranking[1]) + " full of " + self.get_rank_string_pluralize(ranking[2]) + "."			pass		elif ranking[0] == 5:			text = "flush."			pass		elif ranking[0] == 4:			text = self.get_rank_string(ranking[1]) + "-high straight."			pass		elif ranking[0] == 3:			text = "three " + self.get_rank_string_pluralize(ranking[1]) + "."			pass		elif ranking[0] == 2:			text = "a pair of " + self.get_rank_string_pluralize(ranking[1]) + \					" and a pair of " + self.get_rank_string_pluralize(ranking[2]) + "."			pass		elif ranking[0] == 1:			text = "a pair of " + self.get_rank_string_pluralize(ranking[1]) + "."			pass		elif ranking[0] == 0:			text = self.get_rank_string(ranking[1]) + " high."			pass		else:			text = "nothing."			pass		pass		return text	# Pluralize the result from getRankString()	def get_rank_string_pluralize(self, rank):		if rank != 6:			return self.get_rank_string(rank) + "s"		else:			return self.get_rank_string(rank) + "es"	# Given a number between 1 and 14, returns a string describing the rank	@staticmethod	def get_rank_string(rank):		if rank == 1:			rank_str = "ace"		elif rank == 2:			rank_str = "two"		elif rank == 3:			rank_str = "three"		elif rank == 4:			rank_str = "four"		elif rank == 5:			rank_str = "five"		elif rank == 6:			rank_str = "six"		elif rank == 7:			rank_str = "seven"		elif rank == 8:			rank_str = "eight"		elif rank == 9:			rank_str = "nine"		elif rank == 10:			rank_str = "ten"		elif rank == 11:			rank_str = "jack"		elif rank == 12:			rank_str = "queen"		elif rank == 13:			rank_str = "king"		elif rank == 14:			rank_str = "ace"		else:			rank_str = "?"			pass		pass		return rank_str# Evaluate a list of hand objects and returns the id of the winning handdef winner(player1, player2, community):	player1_rank = HandRank(player1, community)	player2_rank = HandRank(player2, community)	score1 = player1_rank.evaluate()	score2 = player2_rank.evaluate()	print("Player " + str(player1.id) + " : " + str(score1))	print("Player " + str(player2.id) + " : " + str(score2))	pass	if comparison(score1, score2) is True:		return player1.id, score1, score2	elif comparison(score1, score2) is False:		return player2.id, score1, score2	else:		return 3, score1, score2	pass# Compare current score with the best scoredef comparison(score1, score2):	for loop_i in range(6):		if score1[loop_i] > score2[loop_i]:			return True		elif score1[loop_i] < score2[loop_i]:			return False		pass	pass