from rank import winnerfrom player import Playerfrom dealer import Dealerfrom strenth import HandStrengthfrom action import Action_dic, Action_predicimport picklestate_dic = {"init": 1, "round": 2}player_turn = {"p1": 0, "p2": 1}save_name = {'id': 0, 'sg': 1, 'st': 2, 'rc': 3, 'sc': 4, 'rf': 5, 'sf': 6, 'rr': 7, 'sr': 8}save_Path = '/Users/collcertaye/WorkSpace/TexasPoker/TexasCFR/venv/train/'class Strategy:    """    strategy chosen accroding to Minimize Counterfactual Regret Algorithm.    """    def __init__(self):        self.players = []        player_1 = Player(1, 0)        player_2 = Player(2, 0)        self.players.append(player_1)        self.players.append(player_2)        self.action_history = []        self.dealer = Dealer()        self.flop_flag = 0        self.turner_flag = 0        self.river_flag = 0        self.score1 = []        self.score2 = []        self.count = 0        self.strategy_set = {}        pass    # Community judge: as the community cards change, we set them once for all rounds.    def river_judge(self, history):        separate_index = [loop_i for loop_i, history_index in enumerate(history) if history_index == 4]        if len(separate_index) == 3:            self.river_flag = 1            self.dealer.deal_river()            pass        else:            pass        pass    def turner_judge(self, history):        separate_index = [loop_i for loop_i, history_index in enumerate(history) if history_index == 4]        if len(separate_index) == 2:            self.turner_flag = 1            self.dealer.deal_turn()            pass        else:            pass        pass    def flop_judge(self, history):        separate_index = [loop_i for loop_i, history_index in enumerate(history) if history_index == 4]        if len(separate_index) == 1:            self.flop_flag = 1            self.dealer.deal_flop()            pass        else:            pass        pass    # Abstraction for every state: the first action must be call-1, and it has three rounds of raise,    # if there is a call after raise, this state will finish, and the different rounds are separated by action-4.    @staticmethod    def state_judge(history):        # If the history is empty, then return init        if history is None:            round_state = state_dic["init"]            return round_state        pass        separate_index = [loop_i for loop_i, history_index in enumerate(history) if history_index == 4]        if len(separate_index) == 0:            if len(history) == 0:                round_state = state_dic["init"]                pass            elif len(history) == 1:                round_state = state_dic["round"]                pass            elif len(history) < 8:                if history[-1] == Action_dic["call"] and history[-2] == Action_dic["call"]:                    round_state = state_dic["init"]                    pass                else:                    round_state = state_dic["round"]                pass            elif len(history) == 8:                round_state = state_dic["init"]                pass            else:                round_state = 0                print("Error in state_judge when history is None!")                exit(0)                pass            return round_state        pass        # Double call-1 action or current round has        if len(history) < separate_index[-1] + 9:            if history[-1] == Action_dic["call"] and history[-2] == Action_dic["call"]:                round_state = state_dic["init"]                pass            else:                round_state = state_dic["round"]            pass        elif len(history) == separate_index[-1] + 9:            round_state = state_dic["init"]            pass        else:            round_state = 0            print("Error in state_judge !")            exit(0)            pass        pass        return round_state    # Judge the game over condition, someone chooses fold or the river-flow round is over.    # Judge the winner and calculate the utility for all players in the leaf node.    def gameover_judge(self, history):        # Count the number of separate index        separate_index = [loop_i for loop_i, history_index in enumerate(history) if history_index == 4]        if len(history) == 0:            pass        else:            if history[-1] == Action_dic["fold"]:                # Return true, it's player_1's turn and player_2 lost                if self.turn_judge(history) is player_turn["p1"]:                    winner_id = 1                    return winner_id                elif self.turn_judge(history) is player_turn["p2"]:                    winner_id = 2                    return winner_id                else:                    print("Error in gameover_judge !")                    exit(0)                    pass                pass            pass        pass        if len(separate_index) == 3:            if (history[-1] == Action_dic["call"] and history[-2] == Action_dic["call"]) \                    or len(history) < separate_index[-1] + 9:                if len(self.score1) == 0 and len(self.score2) == 0:                    winner_id, self.score1, self.score2 = \                        winner(self.players[0], self.players[1], self.dealer.communitycards)                    pass                else:                    if self.score2 > self.score1:                        winner_id = 2                        pass                    elif self.score1 > self.score2:                        winner_id = 1                        pass                    else:                        winner_id = 3                        pass                    pass                return winner_id            elif len(history) == separate_index[-1] + 9:                return False            else:                # print(history)                print("Error in gameover_judge when river flow !")                exit(0)                pass            pass        else:            return False        pass    # Judge the current turn is for which one player    # If the length of current round is an odd, it's player_2's turn, or it's player_1's turn.    @staticmethod    def turn_judge(history):        # Count the number of separate index        separate_index = [loop_i for loop_i, history_index in enumerate(history) if history_index == 4]        if len(separate_index) == 0:            if len(history) % 2 == 0:                return player_turn["p1"]            elif len(history) % 2 == 1:                return player_turn["p2"]            else:                print("Error in turn_judge !")                exit(0)                pass            pass        else:            # print(separate_index)            if (len(history) - separate_index[-1]) % 2 == 0:                return player_turn["p1"]            elif (len(history) - separate_index[-1]) % 2 == 1:                return player_turn["p2"]            else:                print("Error in turn_judge !")                exit(0)                pass            pass        pass    # Every time this function is recall, a point is produced.    # If it is a leaf point, the game is over and recall the utility and regret.    # Next is the steps of CFR:    # step1: choose an action, create a node and transfer the utility as jetton and history action.    # step2: judge the current round and execuate the community cards.    # step3: judge whether the current node is a leaf node or return the utility and call back.    # step4: judge the selectable action and player in current node, and execuate it to step2.    # step5: if the subnode is a terminal node and return the utilities, save them for the current node.    # the current node include: all selectable actions and the utility for each action of the player in this node.    # step6: calculate the average utility in current node.    # step7: calculate the current regret for each selectable action.    # regret calculation method: accumulate the regret in each echo.    # step8: upgrade the strategy accroding to regret matching and save the strategies and regret.    # step9: return the current utility to the paternal node.    def cfr_algorithm(self, history, p1_utility, p2_utility):        # Round judgement, excucute every step once only, actually append the communitycards.        if self.river_flag == 0:            self.river_judge(history)            if self.turner_flag == 0:                self.turner_judge(history)                if self.flop_flag == 0:                    self.flop_judge(history)                    pass                pass            pass        pass        # print("sss", self.river_flag, self.flop_flag, self.turner_flag)        if self.gameover_judge(history) is not False:            # self.count += 1            # print(history, self.count)            if self.gameover_judge(history) == 1:                return [p2_utility, -p2_utility]            elif self.gameover_judge(history) == 2:                return [-p1_utility, p1_utility]            elif self.gameover_judge(history) == 3:                return [0, 0]            else:                print("Error in winner !")                exit(0)                pass            pass        pass        # Save every player's utility in each leaf node.        utility = [0, 0]        # print(history)        # each player make a decision, and calculate the utility        if self.state_judge(history) == state_dic["init"]:            for name, each_action in Action_predic.items():                history_list = history.copy()                if each_action == Action_predic["call"]:                    if len(history) == 0 or len(history) == 1:                        pass                    else:                        history_list.append(4)                        pass                    pass                    history_list.append(each_action)                    value = self.cfr_algorithm(history_list, p1_utility + 1, p2_utility)                    pass                elif each_action == Action_predic["fold"]:                    history_list.append(each_action)                    value = self.cfr_algorithm(history_list, p1_utility, p2_utility)                    pass                else:                    value = []                    # print(each_action)                    print("Error in pre-iteraction !")                    exit(0)                    pass                pass                # print(value, player_turn["p1"], value[player_turn["p1"]])                utility[each_action] = value[player_turn["p1"]]                pass            pass        elif self.state_judge(history) == state_dic["round"]:            utility.append(0)            for name, each_action in Action_dic.items():                history_list = history.copy()                if self.turn_judge(history) == player_turn["p1"]:                    if each_action == Action_dic["call"]:                        history_list.append(each_action)                        value = self.cfr_algorithm(history_list, p1_utility + 1, p2_utility)                        pass                    elif each_action == Action_dic["raise"]:                        history_list.append(each_action)                        value = self.cfr_algorithm(history_list, p1_utility + 2, p2_utility)                        pass                    elif each_action == Action_dic["fold"]:                        history_list.append(each_action)                        value = self.cfr_algorithm(history_list, p1_utility, p2_utility)                        pass                    else:                        value = []                        print("Error in iteraction !")                        exit(0)                        pass                    pass                    utility[each_action] = value[player_turn["p1"]]                    pass                else:                    if each_action == Action_dic["call"]:                        history_list.append(each_action)                        value = self.cfr_algorithm(history_list, p1_utility, p2_utility + 1)                        pass                    elif each_action == Action_dic["raise"]:                        history_list.append(each_action)                        value = self.cfr_algorithm(history_list, p1_utility, p2_utility + 2)                        pass                    elif each_action == Action_dic["fold"]:                        history_list.append(each_action)                        value = self.cfr_algorithm(history_list, p1_utility, p2_utility)                        pass                    else:                        value = []                        print("Error in iteraction !")                        exit(0)                        pass                    pass                    utility[each_action] = value[player_turn["p2"]]                    pass                pass            pass        pass        # # April.20th: load the data in strategy files.        # strategy_file = open(save_Path + 'strategy_set.pickle', 'rb')        # strategy_set = pickle.load(strategy_file)        # for key, value in strategy_set.items():        #     if key == str(history):        #         print(strategy_set[key])        #         pass        #     pass        # pass        self.count += 1        # Rename the history string        rename = 's'        for value in history:            if value == Action_dic['call']:                rename += 'c'                pass            elif value == Action_dic['raise']:                rename += 'r'                pass            elif value == Action_dic['fold']:                rename += 'f'                pass            else:                rename += 'n'                pass            pass        pass        # with open(save_Path + rename + '.pickle', 'rb') as last_file:        #     try:        #         return pickle.load(last_file)        #     except EOFError:        #         return None        #     pass        # pass        last_file = open(save_Path + 'ss' + str(self.count) + '.pickle', 'rb')        last_information = pickle.load(last_file)        last_file.close()        last_strategy = last_information['ss']        # Calculate the average utility in current node.        if self.state_judge(history) == state_dic["init"]:            # probability = [0.5, 0.5]            # average_utility = utility[Action_predic["call"]] * probability[Action_predic["call"]] + \            #     utility[Action_predic["fold"]] * probability[Action_predic["fold"]]            average_utility = utility[Action_predic["call"]] * last_strategy[save_name["sc"]] + \                     utility[Action_predic["fold"]] * last_strategy[save_name["sf"]]            pass        elif self.state_judge(history) == state_dic["round"]:            utility.append(0)            # probability = [1 / 3, 1 / 3, 1 / 3]            # average_utility = utility[Action_dic["call"]] * probability[Action_dic["call"]] + \            #     utility[Action_dic["fold"]] * probability[Action_dic["fold"]] + \            #     utility[Action_dic["raise"]] * probability[Action_dic["raise"]]            average_utility = utility[Action_dic["call"]] * last_strategy[save_name["sc"]] + \                utility[Action_dic["fold"]] * last_strategy[save_name["sf"]] + \                utility[Action_dic["raise"]] * last_strategy[save_name["sr"]]            pass        else:            average_utility = 0            print("Error in calculate average utility !")            exit(0)            pass        pass        # Calculate the current regret for each selectable action.        if self.state_judge(history) == state_dic["init"]:            regret_call = utility[Action_predic["call"]] - average_utility            regret_fold = utility[Action_predic["fold"]] - average_utility            regret_call = max(regret_call, 0)            regret_fold = max(regret_fold, 0)            regret_raise = 0            pass        elif self.state_judge(history) == state_dic["round"]:            regret_call = utility[Action_dic["call"]] - average_utility            regret_raise = utility[Action_dic["raise"]] - average_utility            regret_fold = utility[Action_dic["fold"]] - average_utility            regret_call = max(regret_call, 0)            regret_raise = max(regret_raise, 0)            regret_fold = max(regret_fold, 0)            pass        else:            regret_call = 0            regret_fold = 0            regret_raise = 0            print("Error in calculate average regret !")            exit(0)            pass        pass        # Upgrade the strategy accroding to regret matching.        if self.state_judge(history) == state_dic["init"]:            if regret_call == 0 and regret_fold == 0:                probability = [0.5, 0.5]                pass            else:                probability = [regret_call / (regret_call + regret_fold), regret_fold / (regret_call + regret_fold)]            pass        elif self.state_judge(history) == state_dic["round"]:            if regret_call == 0 and regret_fold == 0 and regret_raise == 0:                probability = [1/3, 1/3, 1/3]                pass            else:                probability = [regret_call / (regret_call + regret_fold + regret_raise),                               regret_fold / (regret_call + regret_fold + regret_raise),                               regret_raise / (regret_call + regret_fold + regret_raise)]            pass        else:            probability = []            print("Error in calculate average regret !")            exit(0)            pass        pass        # In order to save storage, use the logogram:        # in - information name, id - player_id, rc - regret_call, sc - strategy for call,        # rf - regret_fold, sf - strategy fold, rr - regret_raise, sr - strategy for raise.        if self.state_judge(history) == state_dic["init"]:            strength = HandStrength(self.players[0]).get_strength()            # print("hand_strength: ", strength)            information_set = {'in': str(history), 'id': 1, 'sg': strength, 'st': 0,                               'rc': regret_call, 'sc': probability[Action_predic["call"]],                               'rf': regret_fold, 'sf': probability[Action_predic["fold"]],                               'rr': regret_raise, 'sr': 0}            pass        elif self.state_judge(history) == state_dic["round"]:            if self.turn_judge(history) == player_turn["p1"]:                player_id = 2                strength = HandStrength(self.players[1]).get_strength()                pass            elif self.turn_judge(history) == player_turn["p2"]:                player_id = 1                strength = HandStrength(self.players[0]).get_strength()                pass            else:                player_id = 0                strength = 0                print("Error in save name !")                exit(0)                pass            pass            information_set = {'in': str(history), 'id': player_id, 'sg': strength, 'st': 1,                               'rc': regret_call, 'sc': probability[Action_dic["call"]],                               'rf': regret_fold, 'sf': probability[Action_dic["fold"]],                               'rr': regret_raise, 'sr': probability[Action_dic["raise"]]}            pass        else:            information_set = {}            print("Error in save information !")            exit(0)            pass        pass        information_list = []        # print(' in:' + str(information_set["in"]) + '\n' + ' id:' + str(information_set["id"]) +        #       ' sg:' + str(information_set["sg"]) + ' st:' + str(information_set["st"]) + ' rc:'        #       + str(information_set["rc"]) + ' sc:' + str(information_set["sc"]) + ' rf:' + str(information_set["rf"])        #       + ' sf:' + str(information_set["sf"]) + ' rr:' + str(information_set["rr"]) +        #       ' sr:' + str(information_set["sr"]))        for key, value in information_set.items():            if key == 'in':                # print(str(key) + ':' + str(value) + ' ')                print(history, self.count)                pass            else:                information_list.append(value)                # print(str(key) + ':' + str(value) + ' ')            pass        pass        info_set = {'ss': information_list, 'nm': rename}        strategy_file = open(save_Path + 'ss' + str(self.count) + '.pickle', 'wb')        pickle.dump(info_set, strategy_file)        strategy_file.close()        # # Save the strategies and regret.        # file = open(save_Path + 'info.txt', 'a')        # for key, value in information_set.items():        #     print(history, self.count)        #     print(str(key) + ':' + str(value) + ' ')        #     file.write(str(key) + ':' + str(value) + ' ')        #     pass        # pass        # file.write("\n")        # # file.close()        # self.strategy_set[information_set['in']] = []        #        # for key, value in information_set.items():        #     if key == 'in':        #         print(str(key) + ':' + str(value) + ' ')        #         print(history, self.count)        #         pass        #     else:        #         self.strategy_set[information_set['in']].append(value)        #         print(str(key) + ':' + str(value) + ' ')        #     pass        # pass        # Return the current utility to the paternal node.        if self.turn_judge(history) is player_turn["p1"]:            return [-average_utility, average_utility]        elif self.turn_judge(history) is player_turn["p2"]:            return [average_utility, -average_utility]        else:            print("Error in gameover_judge !")            exit(0)            pass        pass    # Counterfactual regret training process    def cfr_process(self):        # Player 0 is always small blind and Player 1 is always big blind        self.players[0].set_blind(0)        self.players[1].set_blind(1)        self.players[0].set_cards(self.dealer.deal_pockets())        self.players[1].set_cards(self.dealer.deal_pockets())        self.cfr_algorithm([], 1, 2)        # strategy_file = open(save_Path + 'strategy_set.pickle', 'wb')        # pickle.dump(self.strategy_set, strategy_file)        # strategy_file.close()        pass